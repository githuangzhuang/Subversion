一.部署redis主从复制
缺点：1.网络繁忙，会产生数据同步延时问题，要传送数据文件到slave
      2.系统繁忙，会产生数据同步延时问题,master另启一个进程收集所有修改数据命令
所有redis一开始都认为是master，所以只要配置从库
从库默认只能读，不能写，同步之后从库断开连接之前数据一直都会有

slaveof 主库IP  端口
slaveof  192.168.4.51 6351

查看主从配置信息
	info replication
永久配置主从复制，从库配置
	vim /etc/redis/6379.conf
	slaveof    主库IP   端口                  去掉注释后修改

临时把从库改为单独主机,命令行，再指定主库又变回从库或重启
	slaveof no  one

设置密码登入，主库从库
	vim /etc/redis/6379.conf
	requirepass "密码"
从库上指定主从的密码,不指定否则无法连接到主库，数据不同步
	vim /etc/redis/6379.conf
	masterauth "123456"

命令行临时修改密码，配置行里面的都可以修改
 config set masterauth "123456"

主从从：把第二台slave指向第一台slave就可以,若从库上有数据，需要把数据备份好，否则作为从库，会把不同步的数据自动覆盖掉
###################################################################################

哨兵服务器：监视master 服务器,主库宕机后，从库自动升级为主库,参考(redis-4.0.8/sentinel.conf)

哨兵服务器上配置：
vim /etc/sentinel.conf
   bind 0.0.0.0
   sentinel monitor redis55 192.168.4.55 6355 1 
   sentinel auth-pass  redis55 123456          
     1=有1台哨兵服务器发现主机坏了，就认为宕机了

开启哨兵服务：
redis-sentinel /etc/sentinel.conf

###################################################################################
启服务AOF和RDB，必须先启AOF，再启RDB，否则AOF里面没有数据，会覆盖RDB，系统是先执行AOF，再执行RDB

持久化RDB
1.Redis数据库文件，全称redis database
2.数据持久化方式之一
3.按照指定时间隔，将内存中的数据集快照写入硬盘
4.术语叫Snapshot快照
5.恢复时，将快照文件直接读入内存
6.数据从内存保存到硬盘的频率，也可以用手动save保存

save 900 1		900秒内且有1次修改就保存
save 300 10
save 60 10000
dump.rdb=内存的数据定期保存到硬盘内
备份数据把dump.rdb备份
cp /var/lib/redis/6379/dump.rdb  /root

恢复数据
1.先停止服务，否则会覆盖掉
2.把dump.rdb 放到/etc xia  
	1. /etc/init.d/redis_6379 stop
	2.cp /root/dump.rdb  /var/lib/redis/6379
	  /etc/init.d/redis_6379 start

优点：高性能的持久化实现--子进程来执行持久化，先将数据写入临时文件，持久化过程结束后，再用这个临时文件替换上次持久化好的文件，过程中主进程不做任何IO操作
缺点：意外宕机时，最后一次持久化的数据会丢失

持久化AOF
1.记录fedis服务所有写操作
2.不断的将新的写操作，追加到文件的末尾
3.使用cat命令可以查看文件内容
优点：可以灵活设置持久化方式，出现宕机时，仅可能丢失一秒的数据
缺点：速度可能会比RDB方式慢，文件体积通常大于RDB方式

vim /etc/redis/6379.conf
	appendonly  yes
	
恢复数据：
	cp /var/lib/redis/6379/appendonly.aof /root
	rm -rf /var/lib/redis/6379/appendonly.aof
	cp /root/appendonly.aof  /var/lib/redis/6379/appendonly.aof
	再启服务 /etc/init.d/redis_6379 start
若在终端上有删除的操作，一定要先vim /root/appendonly.aof把最后的删操作删掉

appendfsync always	有新写操作立即记录,开这个会浪费cup
appendfsync no		从不记录，不会记录到RDB里面
appendfsync	everysec	每秒记录一次
	生产环境下使用 appendfsync everysec

AOF 文件的大小，达到64mb时会自动整理，第二此再达到100%时又会整理一次,改为50，就50%时整理
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb


若时把/var/lib/redis/6379/appendonly.aof 里面的内容搞乱了，将登不进服务
把文件恢复到最后一次的正确操作，若是在中间破坏了，将恢复不了，只能是最后一次
	redis-check-aof --fix appendonly.aof






